---
title: 汇编
date: 2019-07-17 13:47:40
keywords: 汇编
description: Built In Types
categories: 

  - 汇编初级
tags:
  - 8086汇编基础
comments: false
---

# 数据段：data segment

下面的data segment中定义的变量和我们的高阶语言比如c/c++对应的就是全局变量，这个在程序加载到内存中的时候，值和地址都是固定的。全局变量的地址在编译那一刻就确定了，就是我们的数据段；

```c++
;assume is wei zhi ling
assume ds:data, cs:code 

;-----define data,store the memory data -----
data segment    
     
    ;define one byte
    age db 20h   
    ;define two byte,
    num dw 30h 
    db 10 dup(6) 
    ;
    string db 'hello world!$' 
    
data ends


;-----define code ------
code segment  
;code start,so this code is code segment,complier will auto bind the code segment address to cs  
start:    
    ;start will help us ignore following two command
    ;mov ax, code
    ;mov cs, ax  
    ;---first we need to bind data segment to ds
    mov ax, data
    mov ds, ax   
    
    mov ax, num
    mov bh, age                               
    ;prit our db value   
    ;can't use string directly,because string not an address;need to prefix offset
    mov dx, offset num
    mov ah, 9h
    int 21h
    
    
    ;exit the code 
    mov ax,4c00h
    int 21h
    
code ends
;complie end
end start

;

```

# call 和 ret指令

```c++
de segment
    
start: 
    ;bind cs & ds address
    mov ax, stack
    mov ss, ax
    mov ax, data
    mov ds, ax 
                                  
                                  
    ;will use call & ret command 
    ;need to define the ds:dx
    call print 
    mov ax, 1122h
    mov bx, 3344h
    add ax, bx
    

    ;exit
    mov ax, 4c00h
    int 21h 
    
    ;we will Encapsulation the function 
;this just like our c func that will print the string
print: 

    mov dx, offset string 
    ;if we need to print string three times,how you need to do?
    mov ah, 9h
    int 21h
    ret 
    

code ends  
end start
```

函数调用指令:

call指令：调用call的时候，是如何找到定义的代码地址呢？

- call会将下一行的指令的偏移地址入栈,
- 转移到标号处执行指令

ret指令：将栈顶的值出栈，赋值给ip，cs:ip,下一个执行的指令地址

# 栈平衡

```c++
assume cs:code, ds:data, ss:stack

;ss segment

stack segment
    db 100 dup(0)
    
stack ends


;ds segment
data segment 
    
    a dw 0
    
    db 100 dup(0)     
    ;define the hello
    string db 'hello$'
    
data ends


;cs segment
code segment
    
start: 
    ;bind cs & ds address
    mov ax, stack
    mov ss, ax
    mov ax, data
    mov ds, ax 
    ;call sum func
    ；业务逻辑
    push 1122h
    push 3344h
    call sum2
    add sp, 4   ;栈平衡操作                         
                                  

    ;exit
    mov ax, 4c00h
    int 21h 
    
    

;define func with two parameters(store into ss)
；使用栈来传递两个参数
；返回值存放在ax
sum2: 
    mov bp, sp
    mov ax, ss:[bp+2]
    add ax, ss:[bp+4]

    ret
                            
code ends  
end start 


```

- 函数调用前后的栈顶指针要一致;
- 栈如果不平衡的结果：栈空间迟早要被用完；
- 汇编的栈平衡（add sp, 4）是在函数调用完成之后做的，因此对于递归函数，如果没有函数返回的话，也会导致栈空间溢出；

