---
title: TCP&UDP
keywords: iOS面试
date: 2019-04-30 06:47:40
categories: 
  - 面试
tags:
  - 网络
comments: true
---

![4-5-1](https://raw.githubusercontent.com/HaviLee/Blog-Images/master/Tech/10-2-1.png)

# UDP(用户数据报协议)

`什么是UDP?`

回答包括UDP特点和功能。

## UDP的特点？

- **无连接**：我们在发送数据报的时候不需要建立连接。
- **尽最大努力交付**：所以UDP不保证可靠传输
- **面向报文**：既不合并，也拆分；

**<u>既不合并，也拆分</u>**

![4-5-1](https://raw.githubusercontent.com/HaviLee/Blog-Images/master/Tech/10-2-2.png)

> 首先应用层产生一个应用层报文，可大可小，大了不会拆分，小了也不会合并；只会原封不动的传递给运输层，应用层的报文原封不动的作为UDP的首部数据部分，继续传递给IP层。

## UDP的功能？

- 复用
- 分用
- 差错检测

### 复用、分用

![4-5-1](https://raw.githubusercontent.com/HaviLee/Blog-Images/master/Tech/10-2-3.png)

> **复用：**建立的传输过程需要IP地址和端口号，即套嵌字；对于端口来说，同一个IP地址的电脑有不同的应用，同一个应用也可以能使用不同的应用层协议；他们对应的端口号不同；不论从哪个端口传输数据出去，都可以复用传输层的数据报，再经过IP传出去。
>
> **分用：**我们作为接收方，从IP接收到数据报数据，我们拆分为UDP用户数据报，每个数据报文都有源端口和目的端口，我们可以根据目的端口进行分发给不同的端口。

### 差错检测

![4-5-1](https://raw.githubusercontent.com/HaviLee/Blog-Images/master/Tech/10-2-4.png)

> 差错检测需要额外的12字节伪首部；接收方接收到后按照16位为一个单元进行同样的检测。

# TCP(传输控制协议)

`什么是TCP?`

回答包括特点和功能

## TCP的特点？

- 面向连接
- 可靠传输
- 面向字节流
- 流量控制
- 拥塞控制

### 面向连接

- 数据传输之前，需要建立连接：**三次握手**
- 数据传输之后，需要释放连接：**四次挥手**

![4-5-1](https://raw.githubusercontent.com/HaviLee/Blog-Images/master/Tech/10-2-6.png)



*为什么是三次握手？不是两次？*

A：加入客户端发送的SYN数据报文，发送超时，我们的客户端会启用重发策略，重新发送一个SYN；当sever端收到报文后，server会回复SYN，ACK报文，如果是两次的，到这里，连接就建立了；而此时，之前超时的SYN正好又发送给server，server会认为客户端又要进行连接，相当于客户端发生了两次TCP连接。三次话，超时的报文到达server，server也会发送ACK去确认，但是客户端不会再返回ack确认，这样server可以确认这个是超市的SYN。

![4-5-1](https://raw.githubusercontent.com/HaviLee/Blog-Images/master/Tech/10-2-8.png)

> 1.这个连接涉及双方的，7步之后处于半关闭状态，此时客户端不可以向server发送数据，但是server可以向客户端传送数据，之后某个时间，server可以向客户端发送断开连接请求，客户端收到请求后，回复ACK确认。
>
> 2.有两个方面的端口确认，是因为客户端和server建立的通道是**全双工**的，全双工指两端都可以进行发送和回复；因此需要双方面的释放。

## 可靠传输

- 无差错
- 不丢失
- 不重复
- 按序到达

可靠传输是通过**停止等待协议**实现的，具体包括：无差错情况，超时重传，确认丢失，确认迟到

#### 无差错情况

![4-5-1](https://raw.githubusercontent.com/HaviLee/Blog-Images/master/Tech/10-2-9.png)

> 1.客户端发送M1分组报文，Server收到后回复确认M1,客户端收到确认M1之后，才会继续发送分组报文M2,依次往下进行。

#### 超时重传

![4-5-1](https://raw.githubusercontent.com/HaviLee/Blog-Images/master/Tech/10-2-10.png)

> 1.假如客户端发送了M1分组报文，由于网络环境差丢失或者由于中间人劫持被篡改，server端判定这个报文是有差错的会丢弃到
>
> 2.在期许的时间内，没有收到server的确认报文，那么就会产生超时，超时后会进行重传。

#### 确认丢失

![4-5-1](https://raw.githubusercontent.com/HaviLee/Blog-Images/master/Tech/10-2-11.png)

> 1.客户端发送M1分组报文后，server端的确认报文丢失；这个时候客户端仍然根据超时重传进行重传M1;
>
> 2.重传之后，server实际已经接受过M1,server做两件事：丢弃重传的M1和重传确认M1.

#### 确认迟到

![4-5-1](https://raw.githubusercontent.com/HaviLee/Blog-Images/master/Tech/10-2-12.png)

> 1.客户端发送M1分组报文后，server端的确认报文由于网络环境差而迟到，因此客户端会重发M1报文；
>
> 2.重传之后，server实际已经接受过M1,server做两件事：丢弃重传的M1和重传确认M1.
>
> 3.一段时间后，server发送的确认M1到达客户端，客户端收下报文，什么也不做。

## 面向字节流

![4-5-1](https://raw.githubusercontent.com/HaviLee/Blog-Images/master/Tech/10-2-13.png)

> 比如发送方进行数据发送的时候，TCP层面有个发送缓冲，发送方比如会发送13，14,
>
> 不管发送方一次性提交给TCP缓存的数据多大，TCP会根据实际情况进行划分，并不是发送方提交多少个字节就发送多少个字节。

## 流量控制

流量控制是**基于滑动窗口协议**：

A:简单来说：我们的应用程序发送方，接收方server，比如发送方需要继续发送数据的时候，由于我们的接收方的接收窗口很小，由于发送方的发送窗口比较大，发送速率比较快，需要由接收窗口通过向TCP的报文的首部字段调整发送方的速率。

![4-5-1](https://raw.githubusercontent.com/HaviLee/Blog-Images/master/Tech/10-2-14.png)

滑动窗口协议机制：

> 1.发送窗口是基于TCP的；
>
> 2.红色部分是我们的发送窗口的发送缓存，从做到又是序号增大的，也就是说我们通过应用程序提交给TCP缓存的数据是有字节编号的。
>
> 3.标红的是已经发送出去的，已发送的左侧是我们的确认的字节，已发送的右侧是最后一个字节，发送窗口比我们的发送缓存小，比我们的已发送多或者刚好，发送窗口左侧是前沿，右侧是后沿。
>
> 4.发送窗口大小由发送缓存的大小和接收方的接收窗口的大小决定，比如发送方是wifi，接收方是移动网络，如果发送太快，会导致接收方接受缓存累计数据，会造成溢出，因此接收方可以动态的调整发送方的发送窗口的大小；
>
> 5.发送窗口和接收窗口是TCP报文中首部中的两个字段。

## 拥塞控制

- **慢开始、拥塞避免**
- 快恢复、快重传

`请简答TCP的慢启动的特点？`

考察慢开始、拥塞避免的特点

#### 慢开始、拥塞避免

![4-5-1](https://raw.githubusercontent.com/HaviLee/Blog-Images/master/Tech/10-2-15.png)

> 1.横轴代表交互次数，或者轮训次数；纵轴标识拥塞窗口值大小；
>
> 2.开始我们发送一个报文，如果网络没有发生拥塞，下次我们发送两个报文，如果没有拥塞，我们就继续翻倍，指数翻倍（就是慢开始过程）；
>
> 3.当到达门限初始值16的时候，我们采用拥塞避免的策略发送报文，以线性方式；
>
> 4.当发送到达24的时候，可能就会发生网络拥塞(界定网络拥塞，连续三个网络报文没有收到，认为发生网络拥塞)，此时采用乘法减小避免网络拥塞恢复到只发送一个报文的情况；同时把拥塞窗口值减少为之前的一半，在达到门限值前采用慢开始。
>
> 5.快恢复，快重传：实际中拥塞避免到门限值时，会立刻恢复重传；而不是到达慢开始。

