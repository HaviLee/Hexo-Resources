---
title: TCP&UDP
keywords: iOS面试
date: 2019-04-30 06:47:40
categories: 
  - 面试
tags:
  - 网络
comments: true
---

![4-5-1](https://raw.githubusercontent.com/HaviLee/Blog-Images/master/Tech/10-2-1.png)

# UDP(用户数据报协议)

`什么是UDP?`

回答包括UDP特点和功能。

## UDP的特点？

- **无连接**：我们在发送数据报的时候不需要建立连接。
- **尽最大努力交付**：所以UDP不保证可靠传输
- **面向报文**：既不合并，也拆分；

**<u>既不合并，也拆分</u>**

![4-5-1](https://raw.githubusercontent.com/HaviLee/Blog-Images/master/Tech/10-2-2.png)

> 首先应用层产生一个应用层报文，可大可小，大了不会拆分，小了也不会合并；只会原封不动的传递给运输层，应用层的报文原封不动的作为UDP的首部数据部分，继续传递给IP层。

## UDP的功能？

- 复用
- 分用
- 差错检测

### 复用、分用

![4-5-1](https://raw.githubusercontent.com/HaviLee/Blog-Images/master/Tech/10-2-3.png)

> **复用：**建立的传输过程需要IP地址和端口号，即套嵌字；对于端口来说，同一个IP地址的电脑有不同的应用，同一个应用也可以能使用不同的应用层协议；他们对应的端口号不同；不论从哪个端口传输数据出去，都可以复用传输层的数据报，再经过IP传出去。
>
> **分用：**我们作为接收方，从IP接收到数据报数据，我们拆分为UDP用户数据报，每个数据报文都有源端口和目的端口，我们可以根据目的端口进行分发给不同的端口。

### 差错检测

![4-5-1](https://raw.githubusercontent.com/HaviLee/Blog-Images/master/Tech/10-2-4.png)

> 差错检测需要额外的12字节伪首部；接收方接收到后按照16位为一个单元进行同样的检测。

# TCP(传输控制协议)

`什么是TCP?`

回答包括特点和功能

## TCP的特点？

- 面向连接
- 可靠传输
- 面向字节流
- 流量控制
- 拥塞控制

### 面向连接

- 数据传输之前，需要建立连接：**三次握手**
- 数据传输之后，需要释放连接：**四次挥手**

![4-5-1](https://raw.githubusercontent.com/HaviLee/Blog-Images/master/Tech/10-2-6.png)



*为什么是三次握手？不是两次？*

A：加入客户端发送的SYN数据报文，发送超时，我们的客户端会启用重发策略，重新发送一个SYN；当sever端收到报文后，server会回复SYN，ACK报文，如果是两次的，到这里，连接就建立了；而此时，之前超时的SYN正好又发送给server，server会认为客户端又要进行连接，相当于客户端发生了两次TCP连接。三次话，超时的报文到达server，server也会发送ACK去确认，但是客户端不会再返回ack确认，这样server可以确认这个是超市的SYN。

![4-5-1](https://raw.githubusercontent.com/HaviLee/Blog-Images/master/Tech/10-2-8.png)

> 1.这个连接涉及双方的，7步之后处于半关闭状态，此时客户端不可以向server发送数据，但是server可以向客户端传送数据，之后某个时间，server可以向客户端发送断开连接请求，客户端收到请求后，回复ACK确认。
>
> 2.有两个方面的端口确认，是因为客户端和server建立的通道是**全双工**的，全双工指两端都可以进行发送和回复；因此需要双方面的释放。

## 可靠传输

- 无差错
- 不丢失
- 不重复
- 按序到达

可靠传输是通过**停止等待协议**实现的，具体包括：无差错情况，超时重传，确认丢失，确认迟到

#### 无差错情况

![4-5-1](https://raw.githubusercontent.com/HaviLee/Blog-Images/master/Tech/10-2-9.png)

> 1.客户端发送M1分组报文，Server收到后回复确认M1,客户端收到确认M1之后，才会继续发送分组报文M2,依次往下进行。

#### 超时重传

![4-5-1](https://raw.githubusercontent.com/HaviLee/Blog-Images/master/Tech/10-2-10.png)

> 1.假如客户端发送了M1分组报文，由于网络环境差丢失或者由于中间人劫持被篡改，server端判定这个报文是有差错的会丢弃到
>
> 2.在期许的时间内，没有收到server的确认报文，那么就会产生超时，超时后会进行重传。

#### 确认丢失

![4-5-1](https://raw.githubusercontent.com/HaviLee/Blog-Images/master/Tech/10-2-11.png)

> 1.客户端发送M1分组报文后，server端的确认报文丢失；这个时候客户端仍然根据超时重传进行重传M1;
>
> 2.重传之后，server实际已经接受过M1,server做两件事：丢弃重传的M1和重传确认M1.

#### 确认迟到

![4-5-1](https://raw.githubusercontent.com/HaviLee/Blog-Images/master/Tech/10-2-12.png)

> 1.客户端发送M1分组报文后，server端的确认报文由于网络环境差而迟到，因此客户端会重发M1报文；
>
> 2.重传之后，server实际已经接受过M1,server做两件事：丢弃重传的M1和重传确认M1.
>
> 3.一段时间后，server发送的确认M1到达客户端，客户端收下报文，什么也不做。

## 面向字节流

![4-5-1](https://raw.githubusercontent.com/HaviLee/Blog-Images/master/Tech/10-2-13.png)

> 比如发送方进行数据发送的时候，TCP层面有个发送缓冲，发送方比如会发送13，14,
>
> 不管发送方一次性提交给TCP缓存的数据多大，TCP会根据实际情况进行划分，并不是发送方提交多少个字节就发送多少个字节。

## 流量控制

流量控制是**基于滑动窗口协议**：

A:简单来说：我们的应用程序发送方，接收方server，比如发送方需要继续发送数据的时候，由于我们的接收方的接收窗口很小，由于发送方的发送窗口比较大，发送速率比较快，需要由接收窗口通过向TCP的报文的首部字段调整发送方的速率。

![4-5-1](https://raw.githubusercontent.com/HaviLee/Blog-Images/master/Tech/10-2-14.png)

滑动窗口协议机制：

> 1.发送窗口是基于TCP的；
>
> 2.红色部分是我们的发送窗口的发送缓存，从做到又是序号增大的，也就是说我们通过应用程序提交给TCP缓存的数据是有字节编号的。
>
> 3.标红的是已经发送出去的，已发送的左侧是我们的确认的字节，已发送的右侧是最后一个字节，发送窗口比我们的发送缓存小，比我们的已发送多或者刚好，发送窗口左侧是前沿，右侧是后沿。
>
> 4.发送窗口大小由发送缓存的大小和接收方的接收窗口的大小决定，比如发送方是wifi，接收方是移动网络，如果发送太快，会导致接收方接受缓存累计数据，会造成溢出，因此接收方可以动态的调整发送方的发送窗口的大小；
>
> 5.发送窗口和接收窗口是TCP报文中首部中的两个字段。

## 拥塞控制

- **慢开始、拥塞避免**
- 快恢复、快重传

`请简答TCP的慢启动的特点？`

考察慢开始、拥塞避免的特点

#### 慢开始、拥塞避免

![4-5-1](https://raw.githubusercontent.com/HaviLee/Blog-Images/master/Tech/10-2-15.png)

> 1.横轴代表交互次数，或者轮训次数；纵轴标识拥塞窗口值大小；
>
> 2.开始我们发送一个报文，如果网络没有发生拥塞，下次我们发送两个报文，如果没有拥塞，我们就继续翻倍，指数翻倍（就是慢开始过程）；
>
> 3.当到达门限初始值16的时候，我们采用拥塞避免的策略发送报文，以线性方式；
>
> 4.当发送到达24的时候，可能就会发生网络拥塞(界定网络拥塞，连续三个网络报文没有收到，认为发生网络拥塞)，此时采用乘法减小避免网络拥塞恢复到只发送一个报文的情况；同时把拥塞窗口值减少为之前的一半，在达到门限值前采用慢开始。
>
> 5.快恢复，快重传：实际中拥塞避免到门限值时，会立刻恢复重传；而不是到达慢开始。



[Socket]: https://www.jianshu.com/p/a5614e149f8a	"使用socket建立"







**TCP（Transmission Control Protocol 传输控制协议）**

　　面向连接，提供可靠的服务，无重复、无丢失、无差错，面向字节流，只能是点对点，首部 20 字节，全双工。

 

**UDP(User Datagram Protocol用户数据报协议）**

　　无连接，尽最大努力交付，面向报文， 支持一对一、一对多、多对多，首部 8 字节。

 

怎么用 udp 实现 tcp：

　　由于在传输层 udp 已经是不可靠的，那就要在应用层自己实现一 些保证可靠传输的机制，

　　简单来说，要使用 udp 来构建可靠的面向连接的数据传输，就要实现类似于 tcp 的超时重传（定时器），拥塞控制（滑动窗口），有序接收（添加包序号）， 应答确认（ack 和 seq）。

　　目前已经有了实现 udp 可靠运输的机制——udt：主要目的高速广 域网海量数据传输，他是应用层协议。

 

**tcp 如何保证传输的可靠性？** 

　　tcp 是面向连接，可靠的字节流服务。

　　面向连接意味着两个使用 tcp 的应用（通常是一个客户端和一个服务器）在彼此交换数据之前必须先建立一个 tcp 连接。

　　在一个 tcp 连接中，仅有两方进行彼此通信，广播和多播 不能用于 tcp。 

 

**Tcp 通过下列方式提供可靠性：** 

　　将应用数据分割为 tcp 认为最合适发送的数据块；

　　确认机制：当 tcp 收到发自 tcp 链接另一端的数据时，它将发送一个确认（对于收到的请求，给出确认响应）。

　　超时重传：当 tcp 发出一个段后，他启动一个定时器，等待目的端确认收到这个报文段。若不能及时收到一个确认，将重发这个报文段。

　　若 tcp 收到包，校验出包有错，丢弃报文段，不给出响应， tcp 发送端会超时重传；

　　对于重复数据，直接丢弃。

　　对于失序数据进行重新排序，然后交给应用层（tcp 报文段作为 ip 数据报进行传输， 而 ip 数据报的到达会失序，因此 tcp 报文段的到达也可能失序。若必要， tcp 将对收到的数 据进行重新排列，以正确的顺序交给应用层）。

　　流量控制：tcp 可以进行流量控制，防止较快主机致使较慢主机的缓冲区溢出。

　　拥塞控制：当网络拥塞时，减少数据的发送

 

 

**字节流服务：**

　　两个应用程序通过 tcp 连接， tcp 不在字节中插入记录标识符，我们将这种称为字节流服务。 

　　Tcp 对字节流的内容不做任何解释，tcp 不知道传输的字节流数据是二进制数据还是 ascii 字符或其他类型数据，对字节流的解释由 tcp 连接双方的应用层。

 

**面向报文：**

　　面向报文的传输方式是应用层交给UDP多长的报文，UDP就照样发送，即一次发送一个报文。

 

Tcp： 

　　流量控制：防止较快主机使较慢主机缓冲区溢出，是点对点； 

　　拥塞控制： 全局性，防止过多的数据注入网络。慢开始、拥塞避免、快重传、快恢复。  

 

　　tcp 采用滑动窗口进行流量控制，滑动窗口大小可变，窗口大小的单位是字节。 

　　发送窗口在连接建立时由双方确定，但在通信过程中，接收端可以根据自己的资源情况， 随时动态的调整对方的发送窗口上限制。 

 

 

**TCP和UDP的区别：**

 

![img](https://images2018.cnblogs.com/blog/720994/201806/720994-20180627104958129-471208889.png)

 

**TCP/UDP编程模型：**

 

![img](https://images2018.cnblogs.com/blog/720994/201806/720994-20180627105043320-1849577502.png)

 

具体编程时的区别：
　　socket()的参数不同 
　　UDP Server不需要调用listen和accept 
　　UDP收发数据用sendto/recvfrom函数 
　　TCP：地址信息在connect/accept时确定 
　　UDP：在sendto/recvfrom函数中每次均 需指定地址信息 
　　UDP：shutdown函数无效

 

**TCP和UDP协议的一些应用：**

![img](https://images2018.cnblogs.com/blog/720994/201806/720994-20180627113120742-2132544361.png)

 

 

### TCP面向字节流

　　打个比方比喻TCP，你家里有个蓄水池，你可以里面倒水，蓄水池上有个龙头，你可以通过龙头将水池里的水放出来，然后用各种各样的容器装（杯子、矿泉水瓶、锅碗瓢盆）接水。
上面的例子中，往水池里倒几次水和接几次水是没有必然联系的，也就是说你可以只倒一次水，然后分10次接完。另外，水池里的水接多少就会少多少；往里面倒多少水，就会增加多少水，但是不能超过水池的容量，多出的水会溢出。

　　结合TCP的概念，水池就好比接收缓存，倒水就相当于发送数据，接水就相当于读取数据。好比你通过TCP连接给另一端发送数据，你只调用了一次write，发送了100个字节，但是对方可以分10次收完，每次10个字节；你也可以调用10次write，每次10个字节，但是对方可以一次就收完。（假设数据都能到达）但是，你发送的数据量不能大于对方的接收缓存（流量控制），如果你硬是要发送过量数据，则对方的缓存满了就会把多出的数据丢弃。

### UDP面向报文

　　UDP和TCP不同，发送端调用了几次write，接收端必须用相同次数的read读完。UPD是基于报文的，在接收的时候，每次最多只能读取一个报文，报文和报文是不会合并的，如果缓冲区小于报文长度，则多出的部分会被丢弃。也就说，如果不指定MSG_PEEK标志，每次读取操作将消耗一个报文。

### 原因

　　其实，这种不同是由TCP和UDP的特性决定的。TCP是面向连接的，也就是说，在连接持续的过程中，socket中收到的数据都是由同一台主机发出的（劫持什么的不考虑），因此，知道保证数据是有序的到达就行了，至于每次读取多少数据自己看着办。

　　而UDP是无连接的协议，也就是说，只要知道接收端的IP和端口，且网络是可达的，任何主机都可以向接收端发送数据。这时候，如果一次能读取超过一个报文的数据，则会乱套。比如，主机A向发送了报文P1，主机B发送了报文P2，如果能够读取超过一个报文的数据，那么就会将P1和P2的数据合并在了一起，这样的数据是没有意义的。

