---
title: 数据结构之数组
date: 2019-08-04 16:47:40
keywords: 数组
description: 数据结构就是指一组数据的存储结构。算法就是操作数据的一组方法。数据结构和算法是相辅相成的。数据结构是为算法服务的，算法要作用在特定的数据结构之上。 因此，我们无法孤立数据结构来讲算法，也无法孤立算法来讲数据结构。
categories: 
  - 算法
  - 数据结构
tags:
  - 数据结构
comments: false
---

你有没有想过一个问题？**为什么很多编程语言的数组都是从编号0开始？**

# 线性表 Linear List

**就是数据排成像一条线一样的结构；每个线性表上的数据最多只有前和后两个方向。主要有：数组、链表、队列、栈**

![list](https://raw.githubusercontent.com/HaviLee/Blog-Images/master/高手/08042238.png)



# 非线性表

**非线性表中的数据并不是简单的前后关系。**

![list](https://raw.githubusercontent.com/HaviLee/Blog-Images/master/高手/08042246.png)

# 数组

**数组（Array）是一种线性表结构；它使用一组联系的内存空间，来存储一组具有相同类型的数据。**

- 具有线性表结构
- 使用连续的内存空间
- 存放相同类型的数据

## 随机访问

数组由于上面的特性，因此具有了一个特性：**<u>随机访问</u>**。那么数组是如何实现根据下标随机访问数组元素的？

先看下数组在内存中的布局：

![list](https://raw.githubusercontent.com/HaviLee/Blog-Images/master/高手/08042258.png)

上面定义一个长度为10的 **Int** 类型的数组，`int[]a = new int[10]`；因此在计算机内存中给这个数组分配一段连续的内存空间 **1000 - 1039**；而内存块的首地址 **base_address = 1000**;

计算机计算内存地址的时候依据寻址公式：`a[i]_address =  base_address + i * data_byte_size`；其中 **data_byte_size** 数组元素的大小，在这里是 **Int** 就是4个字节；

## 数组”插入“和”删除“

**<u>由于数组为了保持内存的连续性，导致删除、插入两个操作比较低效</u>**

### 插入操作

有长度为N的数组，如果需要将一个数据插入到数组中的第K个位置，为了将第K个位置留出来给新数据，我们需要将第K ~ N这部分数据顺序的往后移动一位。那么时间复杂度是多少？

如果插入数据在数组的末尾，此时不需要移动其他数据，此时时间复杂度为**O(1)**;如果插入数据在数组头部，此时需将所有的元素往后移动一位，此时**最坏的时间复杂度为O(n)**；因为每个位置插入元素概率是一样的，所以平均时间复杂是 **（1+2+….+n）/ n = O(n)**。

**➡️优化：**如果数组不要求数据的有序性，仅仅作为一个存储数据的集合，此时，如果将某个数据插入到第K个位置，为了避免大规模数据迁移，我们可以直接将第K个位置的数据移动到数组尾部，把新的元素直接放入第K个位置。这样就将插入**复杂优化为O(1)**

![list](https://raw.githubusercontent.com/HaviLee/Blog-Images/master/高手/08042341.png)

我们举一个例子。假设数组a[10]中存储了如下5个元素:a，b，c，d，e。
我们现在需要将元素x插入到第3个位置。我们只需要将c放入到a[5]，将a[2]赋值为x即可。最后，数组中的元素如下: a，b，x，d，e，c。

### 删除操作

和插入类似，如果删除数组末尾的数据，则最好情况时间复杂度为O(1);如果删除开头的数据，则最坏情况时间复杂度为O(n);平均情况时间复杂度也为O(n)。

实际上，在某些特殊场景下，我们并不一定非得追求数组中数据的连续性。如果我们将多次删除操作集中在一起执行，删除的效率是不是会提高很多呢?
我们继续来看例子。数组a[10]中存储了8个元素:a，b，c，d，e，f，g，h。现在，我们要依次删除a，b，c三个元素。

![list](https://raw.githubusercontent.com/HaviLee/Blog-Images/master/高手/08042345.png)

**为了避免d，e，f，g，h这几个数据会被搬移三次，我们可以先记录下已经删除的数据。每次的删除操作并不是真正地搬移数据，只是记录数据已经被删除。当数组没有更多空间存储数据时，我们再触发执行一次真正的删除操作，这样就大大减少了删除操作导致的数据搬移。**

## 数组越界



## 容器和数组的对比





> Q：数组和链表的区别？
>
> ❌错误的回答：链表适合插入、删除，时间复杂度是O(1)，数组适合查找、查找的时间复杂度是O(1)。
>
> 准确的来说：数组适合查找操作，但是查找的时间复杂度并不为O(1).即便排好序的数组，使用二分法查找，时间复杂度也是O(logn)。因此应该是 **<u>数组支持随机访问，依据下标随机访问的时间复杂度是O(1)</u>**



