---
title: 数据结构之数组
date: 2019-08-04 16:47:40
keywords: 数组
description: 线性表就是数据排成像一条线一样的结构；每个线性表上的数据最多只有前和后两个方向。主要有：数组、链表、队列、栈。
categories: 
  - 算法
  - 数据结构
tags:
  - 数据结构
comments: false
---

你有没有想过一个问题？**为什么很多编程语言的数组都是从编号0开始？**

# 线性表 Linear List

**就是数据排成像一条线一样的结构；每个线性表上的数据最多只有前和后两个方向。主要有：数组、链表、队列、栈**

![list](https://raw.githubusercontent.com/HaviLee/Blog-Images/master/高手/08042238.png)



# 非线性表

**非线性表中的数据并不是简单的前后关系。**

![list](https://raw.githubusercontent.com/HaviLee/Blog-Images/master/高手/08042246.png)

# 数组

**数组（Array）是一种线性表结构；它使用一组联系的内存空间，来存储一组具有相同类型的数据。**

- 具有线性表结构
- 使用连续的内存空间
- 存放相同类型的数据

## 随机访问

数组由于上面的特性，因此具有了一个特性：**<u>随机访问</u>**。那么数组是如何实现根据下标随机访问数组元素的？

先看下数组在内存中的布局：

![list](https://raw.githubusercontent.com/HaviLee/Blog-Images/master/高手/08042258.png)

上面定义一个长度为10的 **Int** 类型的数组，`int[]a = new int[10]`；因此在计算机内存中给这个数组分配一段连续的内存空间 **1000 - 1039**；而内存块的首地址 **base_address = 1000**;

计算机计算内存地址的时候依据寻址公式：`a[i]_address =  base_address + i * data_byte_size`；其中 **data_byte_size** 数组元素的大小，在这里是 **Int** 就是4个字节；

## 数组”插入“和”删除“

**<u>由于数组为了保持内存的连续性，导致删除、插入两个操作比较低效</u>**

### 插入操作

有长度为N的数组，如果需要将一个数据插入到数组中的第K个位置，为了将第K个位置留出来给新数据，我们需要将第K ~ N这部分数据顺序的往后移动一位。那么时间复杂度是多少？

如果插入数据在数组的末尾，此时不需要移动其他数据，此时时间复杂度为**O(1)**;如果插入数据在数组头部，此时需将所有的元素往后移动一位，此时**最坏的时间复杂度为O(n)**；因为每个位置插入元素概率是一样的，所以平均时间复杂是 **（1+2+….+n）/ n = O(n)**。

**➡️优化：**如果数组不要求数据的有序性，仅仅作为一个存储数据的集合，此时，如果将某个数据插入到第K个位置，为了避免大规模数据迁移，我们可以直接将第K个位置的数据移动到数组尾部，把新的元素直接放入第K个位置。这样就将插入**复杂优化为O(1)**

![list](https://raw.githubusercontent.com/HaviLee/Blog-Images/master/高手/08042341.png)

我们举一个例子。假设数组a[10]中存储了如下5个元素:a，b，c，d，e。
我们现在需要将元素x插入到第3个位置。我们只需要将c放入到a[5]，将a[2]赋值为x即可。最后，数组中的元素如下: a，b，x，d，e，c。

### 删除操作

和插入类似，如果删除数组末尾的数据，则最好情况时间复杂度为O(1);如果删除开头的数据，则最坏情况时间复杂度为O(n);平均情况时间复杂度也为O(n)。

实际上，在某些特殊场景下，我们并不一定非得追求数组中数据的连续性。如果我们将多次删除操作集中在一起执行，删除的效率是不是会提高很多呢?
我们继续来看例子。数组a[10]中存储了8个元素:a，b，c，d，e，f，g，h。现在，我们要依次删除a，b，c三个元素。

![list](https://raw.githubusercontent.com/HaviLee/Blog-Images/master/高手/08042345.png)

**为了避免d，e，f，g，h这几个数据会被搬移三次，我们可以先记录下已经删除的数据。每次的删除操作并不是真正地搬移数据，只是记录数据已经被删除。当数组没有更多空间存储数据时，我们再触发执行一次真正的删除操作，这样就大大减少了删除操作导致的数据搬移。**

## 数组越界

首先来看一段C代码：

```c++
int main(int argc, char *argv[]) {
		int i = 0；
    int arr[3] = {0};
  	for (; i <= 3; i++) {
      	arr[i] = 0;
      	printf("hello world\n")
    }
  	return 0;
}
```

最终我们发现会无限打印“hello world”,为什么？

在C语言中，只要不是访问受限的内存，所有的内存空间都可以自由访问，因此根据上面的寻址公式,得到的 a[3]也会被定位到某块不属于数组的内存上，而这个地址正好是存储变量 i 的内存地址，因此 `a[3] =0 就相当于 i= 0`；所以就会无限循环。

函数体内的局部变量存在栈上，且是连续压栈。在Linux进程的内存布局中，栈区在高地址空间，从高向低增长。变量i和arr在相邻地址，且i比arr的地址大， 所以arr越界正好访问到i。当然，前提是i和arr元素同类型，否则那段代码仍是未决行为。 

## 容器和数组的对比

针对数组类型，很多语言提供了容器类，比如java中的 ArrayList, C++中vector;

**容器：**最大的优势就是可以将很多数组操作的细节封装起来。比如前面提到的数组插入、删除数据时需要搬移其他数据等。另外，它还有一个优 势，就是支持动态扩容。 

数组本身在定义的时候需要预先指定大小，因为需要分配连续的内存空间。如果我们申请了大小为10的数组，当第11个数据需要存储到数组中时，我们就需要重
新分配一块更大的空间，将原来的数据复制过去，然后再将新的数据插入。

作为高级语言编程者，是不是数组就无用武之地了呢?当然不是，有些时候，用数组会更合适些，我总结了几点自己的经验。

1.Java ArrayList无法存储基本类型，比如int、long，需要封装为Integer、Long类，而Autoboxing、Unboxing则有一定的性能消耗，所以如果特别关注性能，或者希 望使用基本类型，就可以选用数组。 

2.如果数据大小事先已知，并且对数据的操作非常简单，用不到ArrayList提供的大部分方法，也可以直接使用数组。 

3.还有一个是我个人的喜好，当要表示多维数组时，用数组往往会更加直观。比如Object[][] array;而用容器的话则需要这样定义:ArrayList<ArrayList > array。 

# 解答开篇

从数组存储的内存模型上来看，“下标”最确切的定义应该是“偏移(offset)”。前面也讲到，如果用a来表示数组的首地址，a[0]就是偏移为0的位置，也就是首地 址，a[k]就表示偏移k个type_size的位置，所以计算a[k]的内存地址只需要用这个公式: 

`a[k]_address = base_address + k * type_size`

但是，如果数组从1开始计数，那我们计算数组元素a[k]的内存地址就会变为: `a[k]_address = base_address + (k-1)*type_size` 

对比两个公式，我们不难发现，从1开始编号，每次随机访问数组元素都多了一次减法运算，**<u>对于CPU来说，就是多了一次减法指令</u>**。



> Q：数组和链表的区别？
>
> ❌错误的回答：链表适合插入、删除，时间复杂度是O(1)，数组适合查找、查找的时间复杂度是O(1)。
>
> 准确的来说：数组适合查找操作，但是查找的时间复杂度并不为O(1).即便排好序的数组，使用二分法查找，时间复杂度也是O(logn)。因此应该是 **<u>数组支持随机访问，依据下标随机访问的时间复杂度是O(1)</u>**



