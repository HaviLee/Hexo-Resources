---
title: 算法之排序3
date: 2019-08-09 19:47:40
keywords: 排序
description: 递归是一种应用非常广泛的算法（或者编程技巧）
categories: 
  - 算法
tags:
  - 排序
comments: false
---

下面的三种排序算法时间复杂度是O(n): **桶排序、计数排序、基排序**。

思考：如何根据年龄给100万的用户排序？

# 桶排序(Bucket sort)

## 原理

将要排序的数据分到几个有序的桶里，每个桶里的数据再进行单独的排序；桶内排完序，再把每个桶里的数据按照顺序依次取出，组成新的有序数列。

![image](https://raw.githubusercontent.com/HaviLee/Blog-Images/master/高手/08241426.png)

## 时间复杂度

**桶排序的时间复杂度是O(n)**

假设要排序的数据有n个，把他平均分到m个桶内，每个桶内有k=n/m个。每个桶内使用快速排序，时间复杂度是O(k*log(k))。m个桶的时间复杂度就是O(m * k *log(k))，即O(n * log(n/m))，当桶的个数m接近n时，log(n/m)是一个非常小的常量，这时桶排序的时间复杂度接近O(n)。

## 桶排序条件

- 要排序的数据容易划分成M个桶，并且桶与桶之间有着天然的大小顺序。
- 数据在各个桶之间的分布是比较均匀的。
- 桶排序比较适合于外部排序中；即数据存储在外部磁盘中，数据量比较大，内存有限，无法全部加载到内存。

例子：有10GB的订单数据，我们希望按订单金额(假设金额都是正整数)进行排序，但是我们的内存有限，只有几百MB，没办法一次性把10GB的数据都加载到内存中。

# 计数排序(Counting sort)

## 原理

计数排序是桶排序的特殊情况，当排序的n个数据，所处的范围不是很大的时候，比如最大值就是k，我们可以将数据分成k个桶。每个桶的数据都是相同的，省掉了桶内排序的时间。

## 例子

全国高考满分900,最低分0分，因此我们可以分成901个桶。

**计数排序和桶排序的非常类似，只是桶的大小的粒度不同**

## 算法推导

- 假设有8个考生，成绩是存放在数组A[8]中：2，5，3，0，2，3，0，3。考生的成绩从0到5；我们使用C[6]表示桶的个数，其中小标对于分数，C[6]中存储的不是分数，而是对应分数的考生的个数。

![image](https://raw.githubusercontent.com/HaviLee/Blog-Images/master/高手/08242156.png)

### 如何快速计算出每个分数的考生在有序数组中的位置

- 对C[6]数组进行顺序求和，那么C[k]里面存放的是小于等于分数k的个数。

![image](https://raw.githubusercontent.com/HaviLee/Blog-Images/master/高手/08242205.png)

- 从后向前扫描数组A。比如扫描到3的时候，从数组C中取出下标为3的值7，也就是说，到目前为止，包括自己，分数小于等于3的考生有7个，也就是说3是输入R中的第7个元素(对于的就是数组的下标6)。当把3放入数组数组R之后，小于3的元素就只有6个了，因此C[3]要响应的减1,变成6。以此类推，完成整个数组A的排序。

![image](https://raw.githubusercontent.com/HaviLee/Blog-Images/master/高手/08242206.png)



```java
//计数排序，a是数组，n是数组大小，假设数组中存储的都是非负整数。
public void countingSort(int[] a, int a) {
  if (n <= 1) return;
  //确定数组的范围
  int max = a[0];
  for (int i=1; i< n; ++i) {
    if (max < a[i]) {
      max = a[i];
    }
  }
  //申请一个数组C来存放相同元素的个数
  int[] c = new int[max + 1];
  for (int i=0; i<=max; ++i) {
    c[i] = 0;//初始为0；
  }
  //计算元素的个数
  for (int i=0; i<n; ++i) {
    c[a[i]]++;
  }
  //累加C中的元素
  for (int i=1; i<=max; i++) {
    c[i] = c[i-1] + c[i];
  }
  //临时数组，存放排完序的元素
  int[] r = new int[n];
  //计算排序的关键步骤。
  for(int i=n-1; i>=0; --i) {
    int index = c[a[i]]-1;//index是得出的该元素应该在的位置
    r[index] = a[i];
    c[a[i]]--;//先将对应位的个数减一;
  }
  //拷贝回原来的数组
  for(int i=0; i<n; i++) {
    a[i] = r[i];
  }
}
```

## 局限性

- 只能应用数据量不大的场景，如果数据范围k比数据n大很多，就不适合
- 数据要求非负；因此很多场景需要先将数据进行非负转换。

# 基数排序(Radix sort)

## 原理

基数排序对要排序的数据是有要求的，需要可以分割出独立的**“**位**”**来比较，而且位之间有递进的关系，如果**a**数据的高位比**b**数据大，那剩下的低位就不用比较了。除此之外，每一位的数据范围不能太大，要可以用线性排序算法来排序，否则，基数排序的时间复杂度就无法做到**O(n)**了。

## 推导

**以排序10万个手机号为例来说明**

- 比较两个手机号码a，b的大小，如果在前面几位中a已经比b大了，那后面几位就不用看了。 
- 借助稳定排序算法的思想，可以先按照最后一位来排序手机号码，然后再按照倒数第二位来重新排序，以此类推，最后按照第一个位重新排序。 
- 经过11次排序后，手机号码就变为有序的了。 
- 每次排序有序数据范围较小，可以使用桶排序或计数排序来完成。
   

![image](https://raw.githubusercontent.com/HaviLee/Blog-Images/master/高手/08242249.png)

## 局限性

- 要求数据可以分割独立的“位”来比较;
- 位之间由递进关系，如果a数据的高位比b数据大，那么剩下的地位就不用比较了;
- 每一位的数据范围不能太大，要可以用线性排序，否则基数排序的时间复杂度无法做到O(n)。

# 总结

- 桶排序、计数排序、基数排序。它们对要排序的数据都有比较苛刻的要求，应用不是非常广泛。如果数据特征比较符合这些排序算法的要求，应用这些算法，会非常高效，线性时间复杂度可以达到O(n)。
- 桶排序和计数排序的排序思想是非常相似的，都是针对范围不大的数据，将数据划分成不同的桶来实现排序。基数排序要求数据可以划分成高低位，位之间有递进关系。比较两个数，我们只需要比较高位，高位相同的再比较低位。而且每一位的数据范围不能太大，因为基数排序算法需要借助桶排序或者计数排序来完成每一个位的排序工作。