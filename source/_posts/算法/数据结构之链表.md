---
title: 数据结构之链表
date: 2019-08-05 16:47:40
keywords: 链表
description: 链表的一个经典的使用场景：就是 **LRU** 缓存淘汰算法。

<u>缓存是一种提高数据读取性能的技术；应用广泛。</u>常见的缓存策略有：**CPU缓存、数据库缓存、浏览器缓存等。**

而缓存的大小不可能无限大，当缓存被用满的时候，数据应该按照哪些策略进行清理呢？常见的缓存淘汰策略有三种：

- **FIFO (First in, First out)**：先进先出策略
- **LFU(Least Frequestly Used)**：最少使用策略
- **LRU(Least Recently Used)：**最近最少使用策略
categories: 
  - 算法
  - 数据结构
tags:
  - 数据结构
comments: false
---

链表的一个经典的使用场景：就是 **LRU** 缓存淘汰算法。

<u>缓存是一种提高数据读取性能的技术；应用广泛。</u>常见的缓存策略有：**CPU缓存、数据库缓存、浏览器缓存等。**

而缓存的大小不可能无限大，当缓存被用满的时候，数据应该按照哪些策略进行清理呢？常见的缓存淘汰策略有三种：

- **FIFO (First in, First out)**：先进先出策略
- **LFU(Least Frequestly Used)**：最少使用策略
- **LRU(Least Recently Used)：**最近最少使用策略

# 链表结构

相对于数组需要一块连续的内存空间来存储，对内存的要求比较高；比如我们需要申请一个大小100M的的数组，如果内存不存在连续的、足够大的内存空间，那么即使剩余总内存空间大于100M仍会失败。

而链表不需要一块连续的内存空间，他可以通过“指针”将零散的内存空间串联起来。如下图对比：

![image](https://raw.githubusercontent.com/HaviLee/Blog-Images/master/高手/08052140.png)

常见的链表有：**单链表、双向链表、循环链表**。

## 单链表

链表为了将零散的内存串起来，每个节点除了存储数据之外，还需要记录链上的下一个结点的地址；把这个记录下个结点地址的指针叫做后继指针 **next**。

![image](https://raw.githubusercontent.com/HaviLee/Blog-Images/master/高手/08052147.png)

- **头结点：**用来记录链表的基地址，有了它，可以遍历得到整条链表。
- **尾结点：**尾结点的next指针不是指向下一个结点，而是指向**NULL**，代表了这是链表的最后一个结点。

### 插入和删除操作

不像数组那样，为了保持内存地址的连续性，需要对数据进行搬移，因此时间复杂度为O(n)。而在链表中内存本身就是不连续的，因此不要进行数据搬移，所以在链表中插入和删除一个数据是很快的。

单纯的针对链表的删除和插入，我们只需考虑相邻结点指针变化，因此对于的时间复杂度是O(1)。

![image](https://raw.githubusercontent.com/HaviLee/Blog-Images/master/高手/08052206.png)

### 随机访问

但是链表想要随机访问第K个元素的话，只能通过指针一个一个的遍历结点，知道找到对于的结点。因此链表的随机访问的性能没有数组好，需要O(n)的时间复杂度。

## 双向链表



## 循环链表

