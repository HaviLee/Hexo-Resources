---
title: 数据结构之链表
date: 2019-08-05 16:47:40
keywords: 链表
description: 链表的一个经典的使用场景：就是 **LRU** 缓存淘汰算法。

<u>缓存是一种提高数据读取性能的技术；应用广泛。</u>常见的缓存策略有：**CPU缓存、数据库缓存、浏览器缓存等。**

而缓存的大小不可能无限大，当缓存被用满的时候，数据应该按照哪些策略进行清理呢？常见的缓存淘汰策略有三种：

- **FIFO (First in, First out)**：先进先出策略
- **LFU(Least Frequestly Used)**：最少使用策略
- **LRU(Least Recently Used)：**最近最少使用策略
categories: 
  - 算法
  - 数据结构
tags:
  - 数据结构
comments: false
---

链表的一个经典的使用场景：就是 **LRU** 缓存淘汰算法。

<u>缓存是一种提高数据读取性能的技术；应用广泛。</u>常见的缓存策略有：**CPU缓存、数据库缓存、浏览器缓存等。**

而缓存的大小不可能无限大，当缓存被用满的时候，数据应该按照哪些策略进行清理呢？常见的缓存淘汰策略有三种：

- **FIFO (First in, First out)**：先进先出策略
- **LFU(Least Frequestly Used)**：最少使用策略
- **LRU(Least Recently Used)：**最近最少使用策略

# 链表结构

相对于数组需要一块连续的内存空间来存储，对内存的要求比较高；比如我们需要申请一个大小100M的的数组，如果内存不存在连续的、足够大的内存空间，那么即使剩余总内存空间大于100M仍会失败。

而链表不需要一块连续的内存空间，他可以通过“指针”将零散的内存空间串联起来。如下图对比：

![image](https://raw.githubusercontent.com/HaviLee/Blog-Images/master/高手/08052140.png)

常见的链表有：**单链表、双向链表、循环链表**。

## 单链表

链表为了将零散的内存串起来，每个节点除了存储数据之外，还需要记录链上的下一个结点的地址；把这个记录下个结点地址的指针叫做后继指针 **next**。

![image](https://raw.githubusercontent.com/HaviLee/Blog-Images/master/高手/08052147.png)

- **头结点：**用来记录链表的基地址，有了它，可以遍历得到整条链表。
- **尾结点：**尾结点的next指针不是指向下一个结点，而是指向**NULL**，代表了这是链表的最后一个结点。

### 插入和删除操作

不像数组那样，为了保持内存地址的连续性，需要对数据进行搬移，因此时间复杂度为O(n)。而在链表中内存本身就是不连续的，因此不要进行数据搬移，所以在链表中插入和删除一个数据是很快的。

单纯的针对链表的删除和插入，我们只需考虑相邻结点指针变化，因此对于的时间复杂度是O(1)。

![image](https://raw.githubusercontent.com/HaviLee/Blog-Images/master/高手/08052206.png)

### 随机访问

但是链表想要随机访问第K个元素的话，只能通过指针一个一个的遍历结点，知道找到对于的结点。因此链表的随机访问的性能没有数组好，需要O(n)的时间复杂度。

## 循环链表

循环链表是一个特殊的单链表；它与单链表唯一的区别就是 **尾结点**。单链表的尾结点指向 NULL,而**循环链表的尾结点指向链表的头结点。**

![image](https://raw.githubusercontent.com/HaviLee/Blog-Images/master/高手/08062025.png)

**优点：**循环链表从链尾到链头比较方便。当要处理的数据具有环形结构的特定的时候，可以采用循环链表。

## 双向链表

**双向链表支持两个方向，每个节点不仅有一个后继指针Next指向后面的结点，还有一个前驱指针pre指向前面的结点。**

![image](https://raw.githubusercontent.com/HaviLee/Blog-Images/master/高手/08062117.png)

1. 双向链表需要额外的两个空间来存储后继结点和前驱结点的地址，因此存储相同的数据，双向链表比单向链表占用更多的内存空间。
2. 双向链表可以支持在O(1)时间复杂度的情况下找到前驱结点。

### 删除复杂度分析

在实际应用中，从链表中删除一个数据主要有以下两种情况

- 删除结点中 **值等于某个给定值** 的结点
- 删除 **给定指针指向** 的结点

**第一种情况：**

无论是单向链表还是双向链表，为了查找到给定值的结点，都需要从头结点一个一个的遍历对比，直到找到给定值存在的结点，然后进行删除。单纯的删除操作时间复杂度是O(1);但是结点的查找的时间复杂度是O(n),因此总的时间复杂度是O(n)

**第二种情况：**

我们已经知道了删除的结点，但是删除某个结点q需要知道其前驱结点p,但是单链表不支持直接获取前驱结点，因此为了获取前驱结点，我们需要重头开始遍历链表，直到 **p -> next = q**。但对于双向链表，因为双向链表具有前驱结点的指针，因此可以在时间复杂度为O(1)的情况下搞定。

同样的，对于插入操作和删除操作具有同样的情况。

除了删除，插入操作外，对于一个 **有序链表** 双向链表的值查询比单向链表的效率也高，因为我们可以根据要查找的值和上次查询的值p作比较，决定是往前还是后进行查找，所以平均只需要查找一半的数据。

**这里使用了<u>空间换时间</u>的设计思想**。当内存空间比较充足的时候，如果我们需要追求代码的执行速度，我么可以选择空间复杂度相对较高、时间复杂度相对低的算法结构；相反内存比较紧张的时候，我们可以反过来使用时间换取空间的的结构。

> 开篇的缓存的例子，就是使用了空间换取时间的设计思想。我们把数据存储在硬盘上，会比较节省内存，但是每次都需要查询硬盘，会比较慢，但是我们可以把数据预先加载到内存中，虽然消耗了内存，但是提高了数据查询速度。

**对于执行较慢的程序，可以通过消耗更多的内存(空间换时间)来进行优化;而消耗过多内存的程序，可以通过消耗更多的时间(时间换空间)来降低内存的消耗。**

### 双向循环链表

![image](https://raw.githubusercontent.com/HaviLee/Blog-Images/master/高手/08071110.png)

# 链表数组性能对比



![image](https://raw.githubusercontent.com/HaviLee/Blog-Images/master/高手/08071332.png)

- 对于数组，内存是连续的，可以借助CPU的缓存机制，预读数组中的数据，可以提高效率。
- 对于链表，在内存中的并不是连续的存储，所以对CPU的缓存不友好，没有办法预读。
- 数组缺点是大小固定，一经声明，就会占用整块连续的内存。数组过大，容易出现内存不足，数组过小，容易出现不够用的情况，需要重新分配内存，分厂耗时。
- 链表本身没有大小限制，可以使用零碎的内存空间。

# 链表编程技巧

## 理解指针、引用

**指针含义：**将某个变量赋值给指针，实际上就是将这个变量的地址赋值给指针。或者**<u>指针中存储了这个变量的内存地址，这个地址指向了这个变量，通过这个指针就可以找到这个变量。</u>**

> - `p -> next = q`；意味着p结点的next指针存储了q结点的**内存地址**。
> - `p -> next = p -> next -> next`：表示p结点中的next指针存储了p结点的下下一个结点的内存地址。



## 警惕指针丢失和内存泄露

![iamge](https://raw.githubusercontent.com/HaviLee/Blog-Images/master/高手/08082122.png)

- 插入结点导致指针丢失和内存泄露

  `p -> next = x //将p的next指针指向x结点`

  `x -> next = p -> next//应该将x的next指针指向b结点`

  上面的代码导致b之后的数据丢失。正确的做法是将上面的两行顺序颠倒下。

- 删除结点，要保证**手动释放内存**

## 利用哨兵简化实现难度

**含义：**哨兵对象是为了解决“边界问题”的，不直接参与业务逻辑。主要针对解决插入**第一个结点**和**最后一个结点**的情况特殊处理。

![iamge](https://raw.githubusercontent.com/HaviLee/Blog-Images/master/高手/08082151.png)

- 有哨兵结点的链表称为带头链表，没有哨兵结点的链表叫做不带头链表。
- 哨兵概念在插入排序、归并排序、动态规划中用到。

**代码一：**不使用哨兵思想

```c++
//在数组a中查找key，返回key所在的位置，其中n代表数组a的长度
int find(char *a, int n, char key) {
  //边界条件处理，如果a == nil,或者 n <= 0,则数组为空
  if (a === null || n <= 0) {
    return -1;
  }
  int i = 0;
  while(i < n) {
    if (a[i] == key) {
      return i;
    }
    ++i;
  }
  return -1
  
}
```

**代码二：**使用哨兵思想



```c++
//在数组a中查找key，返回key所在的位置，其中n代表数组a的长度
// a = {4, 2, 3, 5, 9, 6} n=6 key = 6
int find(char *a, int n, char key) {
  if (a === null || n <= 0) {
    return -1;
  }
  //首先这里要将a[n-1]的值替换为key,所以特殊处理这个值
  if (a[n-1] === key) {
    return n-1;
  }
  //把a[n-1]的值保持在临时变量tmp中，以便后面恢复。tmp = 6;
  //这样的目的是为了：find函数代码不会改变a数组中的内容。
  char tmp = a[n-1];
  // 把key的值放到a[n-1]中，此时a = {4, 2, 3, 5, 9, 7} 
  a[n-1] = key;
  int i = 0;
  // while 循环比起代码一，少了i<n这个比较操作
  while (a[i] != key) { 
    ++i;
  }
  // 恢复a[n-1]原来的值,此时a= {4, 2, 3, 5, 9, 6} a[n-1] = tmp;
  if (i == n-1) {
  	// 如果i == n-1说明，在0...n-2之间都没有key，所以返回-1 
    return -1;
  } else {
  	// 否则，返回i，就是等于key值的元素的下标
    return i;
  }
}
```

使用哨兵省掉了比较语句 i < n，但是对于上完的执行代码的时候，累积的时间就很明显。

## 留意边界条件处理

主要考虑有下面的边界条件：

- 链表为空的时候，代码能否正常工作
- 链表只包含一个结点时，代码能否正常工作
- 链表只包含两个结点时，代码能够正常工作
- 在处理链头和链尾的时候，代码能否可以正常工作

## 画图辅助思考

![image](https://raw.githubusercontent.com/HaviLee/Blog-Images/master/高手/08102011.png)

## 多写多练

多多练习：

- 单链表反转 
- 链表中环的检测 
- 两个有序的链表合并 
- 删除链表倒数第n个结点 
- 求链表的中间结点 



# 解答开篇

如何基于链表实现LRU缓存淘汰算法？

**思路：**我们维护一个有序链表，越靠近链表尾部的结点是越早之前访问的。当有一个新的数据被访问的时候，我们需要从链表头部开始顺序遍历。

1. 如果此前的数据之前已经缓存在链表中，我们遍历得到这个数据对应的结点，并将其从原来的位置删除，然后再插入到链表头部。
2. 如果数据没有在缓存中，分为两种：
   - 如果此时缓存未满，则直接将该结点插入链表的头部。
   - 如果缓存已满，先从尾部删除结点，然后将新的结点插入头部。

**时间复杂度 O(n)**

因为不管内存有没有满，我们都需要遍历链表，因此该算法的时间复杂度是O(n)。

后面我么可以使用 **散列表(Hash table)** 进行优化，可以将时间复杂度将为O(1)。

