---
title: 数据结构之链表
date: 2019-08-05 16:47:40
keywords: 链表
description: 链表的一个经典的使用场景：就是 **LRU** 缓存淘汰算法。

<u>缓存是一种提高数据读取性能的技术；应用广泛。</u>常见的缓存策略有：**CPU缓存、数据库缓存、浏览器缓存等。**

而缓存的大小不可能无限大，当缓存被用满的时候，数据应该按照哪些策略进行清理呢？常见的缓存淘汰策略有三种：

- **FIFO (First in, First out)**：先进先出策略
- **LFU(Least Frequestly Used)**：最少使用策略
- **LRU(Least Recently Used)：**最近最少使用策略
categories: 
  - 算法
  - 数据结构
tags:
  - 数据结构
comments: false
---

链表的一个经典的使用场景：就是 **LRU** 缓存淘汰算法。

<u>缓存是一种提高数据读取性能的技术；应用广泛。</u>常见的缓存策略有：**CPU缓存、数据库缓存、浏览器缓存等。**

而缓存的大小不可能无限大，当缓存被用满的时候，数据应该按照哪些策略进行清理呢？常见的缓存淘汰策略有三种：

- **FIFO (First in, First out)**：先进先出策略
- **LFU(Least Frequestly Used)**：最少使用策略
- **LRU(Least Recently Used)：**最近最少使用策略

# 链表结构

相对于数组需要一块连续的内存空间来存储，对内存的要求比较高；比如我们需要申请一个大小100M的的数组，如果内存不存在连续的、足够大的内存空间，那么即使剩余总内存空间大于100M仍会失败。

而链表不需要一块连续的内存空间，他可以通过“指针”将零散的内存空间串联起来。如下图对比：

![image](https://raw.githubusercontent.com/HaviLee/Blog-Images/master/高手/08052140.png)

常见的链表有：**单链表、双向链表、循环链表**。

## 单链表

链表为了将零散的内存串起来，每个节点除了存储数据之外，还需要记录链上的下一个结点的地址；把这个记录下个结点地址的指针叫做后继指针 **next**。

![image](https://raw.githubusercontent.com/HaviLee/Blog-Images/master/高手/08052147.png)

- **头结点：**用来记录链表的基地址，有了它，可以遍历得到整条链表。
- **尾结点：**尾结点的next指针不是指向下一个结点，而是指向**NULL**，代表了这是链表的最后一个结点。

### 插入和删除操作

不像数组那样，为了保持内存地址的连续性，需要对数据进行搬移，因此时间复杂度为O(n)。而在链表中内存本身就是不连续的，因此不要进行数据搬移，所以在链表中插入和删除一个数据是很快的。

单纯的针对链表的删除和插入，我们只需考虑相邻结点指针变化，因此对于的时间复杂度是O(1)。

![image](https://raw.githubusercontent.com/HaviLee/Blog-Images/master/高手/08052206.png)

### 随机访问

但是链表想要随机访问第K个元素的话，只能通过指针一个一个的遍历结点，知道找到对于的结点。因此链表的随机访问的性能没有数组好，需要O(n)的时间复杂度。

## 循环链表

循环链表是一个特殊的单链表；它与单链表唯一的区别就是 **尾结点**。单链表的尾结点指向 NULL,而**循环链表的尾结点指向链表的头结点。**

![image](https://raw.githubusercontent.com/HaviLee/Blog-Images/master/高手/08062025.png)

**优点：**循环链表从链尾到链头比较方便。当要处理的数据具有环形结构的特定的时候，可以采用循环链表。

## 双向链表

**双向链表支持两个方向，每个节点不仅有一个后继指针Next指向后面的结点，还有一个前驱指针pre指向前面的结点。**

![image](https://raw.githubusercontent.com/HaviLee/Blog-Images/master/高手/08062117.png)

1. 双向链表需要额外的两个空间来存储后继结点和前驱结点的地址，因此存储相同的数据，双向链表比单向链表占用更多的内存空间。
2. 双向链表可以支持在O(1)时间复杂度的情况下找到前驱结点。

### 删除复杂度分析

在实际应用中，从链表中删除一个数据主要有以下两种情况

- 删除结点中 **值等于某个给定值** 的结点
- 删除 **给定指针指向** 的结点

**第一种情况：**

无论是单向链表还是双向链表，为了查找到给定值的结点，都需要从头结点一个一个的遍历对比，直到找到给定值存在的结点，然后进行删除。单纯的删除操作时间复杂度是O(1);但是结点的查找的时间复杂度是O(n),因此总的时间复杂度是O(n)

**第二种情况：**

我们已经知道了删除的结点，但是删除某个结点q需要知道其前驱结点p,但是单链表不支持直接获取前驱结点，因此为了获取前驱结点，我们需要重头开始遍历链表，直到 **p -> next = q**。但对于双向链表，因为双向链表具有前驱结点的指针，因此可以在时间复杂度为O(1)的情况下搞定。

同样的，对于插入操作和删除操作具有同样的情况。

除了删除，插入操作外，对于一个 **有序链表** 双向链表的值查询比单向链表的效率也高，因为我们可以根据要查找的值和上次查询的值p作比较，决定是往前还是后进行查找，所以平均只需要查找一半的数据。

**这里使用了<u>空间换时间</u>的设计思想**。当内存空间比较充足的时候，如果我们需要追求代码的执行速度，我么可以选择空间复杂度相对较高、时间复杂度相对低的算法结构；相反内存比较紧张的时候，我们可以反过来使用时间换取空间的的结构。

> 开篇的缓存的例子，就是使用了空间换取时间的设计思想。我们把数据存储在硬盘上，会比较节省内存，但是每次都需要查询硬盘，会比较慢，但是我们可以把数据预先加载到内存中，虽然消耗了内存，但是提高了数据查询速度。

**对于执行较慢的程序，可以通过消耗更多的内存(空间换时间)来进行优化;而消耗过多内存的程序，可以通过消耗更多的时间(时间换空间)来降低内存的消耗。**

### 双向循环链表

![image](https://raw.githubusercontent.com/HaviLee/Blog-Images/master/高手/08071110.png)

# 链表数组性能对比



![image](https://raw.githubusercontent.com/HaviLee/Blog-Images/master/高手/08071332.png)

- 对于数组，内存是连续的，可以借助CPU的缓存机制，预读数组中的数据，可以提高效率。
- 对于链表，在内存中的并不是连续的存储，所以对CPU的缓存不友好，没有办法预读。
- 数组缺点是大小固定，一经声明，就会占用整块连续的内存。数组过大，容易出现内存不足，数组过小，容易出现不够用的情况，需要重新分配内存，分厂耗时。
- 链表本身没有大小限制，可以使用零碎的内存空间。

# 链表编程技巧

## 理解指针、引用



## 警惕指针丢失和内存泄露



## 利用

## 

# 解答开篇

如何基于链表实现LRU缓存淘汰算法？

**思路：**我们维护一个有序链表，越靠近链表尾部的结点是越早之前访问的。当有一个新的数据被访问的时候，我们需要从链表头部开始顺序遍历。

1. 如果此前的数据之前已经缓存在链表中，我们遍历得到这个数据对应的结点，并将其从原来的位置删除，然后再插入到链表头部。
2. 如果数据没有在缓存中，分为两种：
   - 如果此时缓存未满，则直接将该结点插入链表的头部。
   - 如果缓存已满，先从尾部删除结点，然后将新的结点插入头部。

**时间复杂度 O(n)**

因为不管内存有没有满，我们都需要遍历链表，因此该算法的时间复杂度是O(n)。

后面我么可以使用 **散列表(Hash table)** 进行优化，可以将时间复杂度将为O(1)。

