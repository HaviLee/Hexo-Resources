---
title: 算法之排序优化
date: 2019-08-10 19:47:40
keywords: 排序
description: 如何实现一个通用的、高性能的排序函数?
categories: 
  - 算法
tags:
  - 排序
comments: false
---

如何实现一个通用的、高性能的排序函数?

# 排序算法的选择

![image](https://raw.githubusercontent.com/HaviLee/Blog-Images/master/高手/08250931.png)

- 小规模的数据，选择时间复杂度为O(n2)的算法
- 大规模的数据，选择时间复杂度为O(nlog(n))算法
- 一般为了兼顾，首选时间复杂度是O(nlog(n))的算法

# 快速排序优化

快排的最坏时间复杂度是O(n2)；主要是如果数据是有序或者接近有序，每次分区都选择最后一个元素，那么时间复杂度就会退化为O(n2);主要是我们的 <u>**分区点**</u> 选的不合理。

**理想的分区点：被分区点分开的两个区，数据的数量应该差不多**

- **三数取中法**（区间取点法）

  从区间的首、尾、中间分别取出一个数据，对比大小，取这三个数据的中间值作为分区点。这样每隔某个固定的长度，取出数据比较，然后将中间值作为分区点。

- **随机法**

  随机法就是每次从要排序的区间中，随机选择一个元素作为分区点。

# 例子

举例说明 **Glibc中的qsort()** 方法。

- qsort()会优先使用 **归并排序** 处理输入数据，归并排序的空间复杂度是O(n)，对于小数据量比较合适。

- 对于大数据量，qsort()会使用快速排序算法来排序。

- qsort()是如何选择快排的分区点的：使用 **三数取中法**

- qsort()不仅仅使用 **归并排序、快速排序、插入排序**

  在快速排序的过程中，当要排序的区间中，元素的个数小于等于4时，qsort()就退化为插入排序，不再继续用递归来做快速排序，因为我们前面也讲过，在小规模数据面前，**O(n****2****)**时间复杂度的算法并不一定比**O(nlogn)**的算法执行时间长

  