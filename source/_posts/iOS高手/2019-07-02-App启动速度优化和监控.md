---
title: App启动速度优化和监控
date: 2019-07-02 13:47:40
categories: [iOS]
tags: [iOS 高手]
---

# App启动时都做了哪些事？

- 冷启动：App点击启动前，他的进程不在系统里，需要系统创建一个进程分配给它的情况；这是一个完整的启动过程。
- 热启动：App在冷启动后用户将App退后台，在App的进程还在系统里的情况下，用户重新进入App的过程。

 APP启动时间指用户点击App开始到用户看到第一个界面之间的时间；主要包括三个阶段：

1. main( )函数执行前；
2. main( )函数执行后；
3. 首屏渲染完成后；

<img src="https://raw.githubusercontent.com/HaviLee/Blog-Images/master/高手/Screen%20Shot%202019-07-03%20at%2023.11.29.png" align='center' height="400px" width="400px" >

## Main()函数执行前

- 加载可执行文件（App的.o 文件的集合）；
- 加载动态链接库，**进行rebase指针跳整合bind符号绑定**；
- Objc运行时的处理；包括Objc相关类的注册、Category注册、selector唯一性检查；
- 初始化，包括+ load()方法、attribute(constructor)修饰的函数的调用、创建c++静态全局变量

对应的这个阶段的优化策略有：

- **减少动态库加载。**苹果建议将使用更少的动态库，较多动态库时，合并多个动态库为一个，数量上，最多支持6个非系统动态库合并为一个。
- 减少加载启动后不会使用的类或者方法；
- +load()方法里面的东西可以放到**渲染首屏完成后再执行**，或者使用+initialize()方法替换。在load方法里面，进行运行时方法替换操作会带来4毫秒的消耗；
- 控制C++全局变量的数量；

## Main()函数执行后

指的是从main函数执行到Appdelegate的didFinishLaunchingWithOptions方法里面首屏渲染相关方法执行完成。

首页的业务代码执行就是在这个阶段，主要有：

- 首屏初始化需要配置文件的读写操作
- 首屏列表大数据的读取
- 首屏渲染的大量计算

这里的优化主要是app启动的时候只初始化需要的功能，其他功能懒加载。

## 首屏渲染完成后

指的是从首屏渲染完成开始到 didFinishLaunchingWithOptions方法作用域结束。

这个阶段主要是在做非首屏其他业务服务模块的初始化、监听的注册、配置文件的读取。

![过程](https://raw.githubusercontent.com/HaviLee/Blog-Images/master/高手/Screen%20Shot%202019-07-04%20at%2006.51.44.png)

# 优化方向

## 功能级别的启动优化

主要指的是从 mian() 函数执行后这个阶段下手。思路是：main()函数开始执行后到首屏渲染完成前只处理首屏相关的业务，其他非首屏业务的初始化、监听注册、配置文件的读取都放到首屏渲染完成后。

## 方法级别的启动优化

主要指检查首屏渲染完成前主线程上有哪些耗时的操作，将耗时的操作延后或者优化为异步执行。这些耗时主要有加载、编辑，存储图片和资源文件等。

还有一类就是单个耗时不多，但是由于大量堆积也会造成耗时；比如 +load方法， ReactiveCocoa信号创建。

# 启动监控

## pre-main 启动时间检测

Xcode 提供了一个很赞的方法，只需要在 Edit scheme -> Run -> Arguments 中将环境变量 DYLD_PRINT_STATISTICS 设为 1，就可以看到 main 之前各个阶段的时间消耗。

```c++
Total pre-main time: 341.32 milliseconds (100.0%)
         dylib loading time: 154.88 milliseconds (45.3%)
        rebase/binding time:  37.20 milliseconds (10.8%)
            ObjC setup time:  52.62 milliseconds (15.4%)
           initializer time:  96.50 milliseconds (28.2%)
           slowest intializers :
               libSystem.dylib :   4.07 milliseconds (1.1%)
    libMainThreadChecker.dylib :  30.75 milliseconds (9.0%)
                  AFNetworking :  19.08 milliseconds (5.5%)
                        LDXLog :  10.06 milliseconds (2.9%)
                        Bigger :   7.05 milliseconds (2.0%)

```

还有一个方法获取更详细的时间，只需将环境变量 DYLD_PRINT_STATISTICS_DETAILS 设为 1 就可以。

```c++
total time: 1.0 seconds (100.0%)
  total images loaded:  243 (0 from dyld shared cache)
  total segments mapped: 721, into 93608 pages with 6173 pages pre-fetched
  total images loading time: 817.51 milliseconds (78.3%)
  total load time in ObjC:  63.02 milliseconds (6.0%)
  total debugger pause time: 683.67 milliseconds (65.5%)
  total dtrace DOF registration time:   0.07 milliseconds (0.0%)
  total rebase fixups:  2,131,938
  total rebase fixups time:  37.54 milliseconds (3.5%)
  total binding fixups: 243,422
  total binding fixups time:  29.60 milliseconds (2.8%)
  total weak binding fixups time:   1.75 milliseconds (0.1%)
  total redo shared cached bindings time:  29.32 milliseconds (2.8%)
  total bindings lazily fixed up: 0 of 0
  total time in initializers and ObjC +load:  93.76 milliseconds (8.9%)
                           libSystem.dylib :   2.58 milliseconds (0.2%)
               libBacktraceRecording.dylib :   3.06 milliseconds (0.2%)
                            CoreFoundation :   1.85 milliseconds (0.1%)
                                Foundation :   2.61 milliseconds (0.2%)
                libMainThreadChecker.dylib :  42.73 milliseconds (4.0%)
                                   ModelIO :   1.93 milliseconds (0.1%)
                              AFNetworking :  18.76 milliseconds (1.7%)
                                    LDXLog :   9.46 milliseconds (0.9%)
                        libswiftCore.dylib :   1.16 milliseconds (0.1%)
                   libswiftCoreImage.dylib :   1.51 milliseconds (0.1%)
                                    Bigger :   3.91 milliseconds (0.3%)
                              Reachability :   1.48 milliseconds (0.1%)
                             ReactiveCocoa :   1.56 milliseconds (0.1%)
                                SDWebImage :   1.41 milliseconds (0.1%)
                             SVProgressHUD :   1.23 milliseconds (0.1%)
total symbol trie searches:    133246
total symbol table binary searches:    0
total images defining weak symbols:  30
total images using weak symbols:  69
```

## 常用的检测监控手段

- **定时抓取主线程上的方法调用堆栈，计算一段时间里各个方法的耗时**

  Xcode自带的Time Profiler就是采用这种方式；优点是：开发成本低；缺点是：精确度不够高；

  这种抓取涉及到定时时间间隔的长短：时间段了，容易漏掉一些方法，时间长了，抓取堆栈这个方法本身也会耗时。一般采用0.01s，这个对整体耗时影响小，不过很多耗时不是很精准。

- **对 objc_msgSend 方法进行hook来掌控所有的方法执行消耗 **

  hook的意思就是：在原方法开始执行时换成执行你指定的方法，或者在原方法执行前后执行你指定的方法，达到掌握和改变指定方法的目的。

  缺点是：只能针对 Objective-C 方法。c方法和block需要借助 **libffi** 的 **ffi_call** 来完成。

# 实现耗时检测工具







> 参考
>
> [如何精确度量 iOS App 的启动时间]: https://www.jianshu.com/p/c14987eee107